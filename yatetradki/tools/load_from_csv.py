#!/usr/bin/env python2

# See
# https://www.juliensobczak.com/tell/2016/12/26/anki-scripting.html
#


import argparse
import io
from os import getcwd
from os import getenv
from os.path import join
import sys

#sys.path.insert(0, '/usr/share/anki')

from anki.collection import Collection
from yatetradki.tools.log import get_logger
from yatetradki.tools.pronunciation import Pronunciation
from yatetradki.utils import cleanup_query

_logger = get_logger('load_from_csv')


#COLLECTION = '/home/bz/Documents/Anki/bz/collection.anki2'
COLLECTION = '/home/bz/.local/share/Anki2/bz/collection.anki2'

def web_sync(col):
    user = getenv('ANKIWEB_USER')
    password = getenv('ANKIWEB_PASSWORD')
    auth_key = col.sync_login(user, password, None)
    col.sync_collection(auth_key, sync_media=True)

def escape(s): return s.replace('"', '\\"')

def load_from_csv(args):
    cwd = getcwd()
    col = Collection(COLLECTION)
    pronunciation = Pronunciation(args.audio)

    # Set the model
    modelBasic = col.models.by_name(args.model)
    deck = col.decks.by_name(args.deck)
    col.decks.select(deck['id'])
    col.decks.current()['mid'] = modelBasic['id']

    query_template = 'deck:"%s" note:"%s" word:"%s"'
    for line in io.open(join(cwd, args.csv), encoding='utf8'):
        word, example, meaning = line.split('\t')
        query = query_template % (args.deck, args.model, escape(word))
        # _logger.info('>>> QUERY: %s', query)
        found_notes = col.find_notes(query)

        if found_notes:
            _logger.debug('Duplicate notes (%s) for word %s: %s',
                          len(found_notes), word, found_notes)
            if not args.update:
                _logger.debug('Skipping word %s', word)
                continue
            _logger.debug('Updating note %s', found_notes[0])
            note = col.get_note(found_notes[0])
        else:
            _logger.info('Notes not found for word %s, creating new one', word)
            note = col.newNote()
        note.note_type()['did'] = deck['id']

        fields = {
            'Word': word,
            'Example': example,
            'Description': meaning,
        }
        _logger.debug('Fields to set: %s', fields)

        if args.audio and args.audio != 'none':
            pronunciation.fill(word, col, fields)

        current, new = [], []
        for field, value in fields.items():
            current.append(note.fields[args.fields.index(field)])
            new.append(value)
        if current == new: continue

        for field, value in fields.items():
            note.fields[args.fields.index(field)] = value

        if found_notes:
            _logger.info('Updated: %s', word)
        else:
            col.addNote(note)
            _logger.info('Added: %s', word)

        # note.flush()
        col.update_note(note)

    if args.sync:
        web_sync(col)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--csv", help="File to import data from (it actually splits by TAB, to it's a TSV file)", required=False)
    parser.add_argument("--deck", help="Deck name to import to", required=True)
    parser.add_argument("--model", help="Model to use (card type)", required=True)
    parser.add_argument("--fields", help="List of fields of the model", required=True)
    parser.add_argument("--update", help="True if existing notes should be updated",
        default=False, action='store_true')
    parser.add_argument("--audio", choices=['none', 'norwegian', 'korean', 'english'],
        help="If set, add audio generated by TTS depending on the choice",
        default='none')
    parser.add_argument("--sync", help="Run web sync after adding audio in case there were changes",
        default=False, action='store_true')
    args = parser.parse_args()
    args.fields = args.fields.split(',')
    _logger.info('Args: %s', args)

    load_from_csv(args)


if __name__ == '__main__':
    main()
